<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: xml | Mandubian Blog]]></title>
  <link href="http://www.mandubian.com/blog/categories/xml/atom.xml" rel="self"/>
  <link href="http://www.mandubian.com/"/>
  <updated>2012-07-14T13:38:05+02:00</updated>
  <id>http://www.mandubian.com/</id>
  <author>
    <name><![CDATA[Pascal Voitot]]></name>
    <email><![CDATA[pascal.voitot.dev@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[xmlsoap-ersatz]]></title>
    <link href="http://www.mandubian.com/blog/2012/07/14/xmlsoap-ersatz/"/>
    <updated>2012-07-14T00:59:00+02:00</updated>
    <id>http://www.mandubian.com/blog/2012/07/14/xmlsoap-ersatz</id>
    <content type="html"><![CDATA[<h1>XML/SOAP to/from scala structures with <em>xmlsoap-ersatz</em></h1>

<blockquote><p><a href="https://github.com/mandubian/scala-xmlsoap-ersatz">xmlsoap-ersatz</a> is a toolset to help people serialize/deserialize XML/SOAP with Scala. It doesn't try to respect any standard but it allows to interprete and generate any XML format with any standard you require.</p></blockquote>

<p>It was developed to be used with <a href="http://www.playframework.org">Play2/Scala</a> but it can work standalone as it doesn't depend on any other library.</p>

<p>xmlsoap-ersatz uses the same design as Play2 Json serialization/deserialization based on <strong>implicit typeclasses</strong>. This mechanism is very clean, robust and generic. Please note that implicits are NOT used as implicit CONVERSIONS which are often tricky and sometimes dangerous!</p>

<p><em>xmlsoap-ersatz is still draft library so if you discover anything wrong, don't hesitate to tell it</em></p>

<blockquote><p>xmlsoap-ersatz is an <a href="https://github.com/mandubian/scala-xmlsoap-ersatz">opensource public github</a> so don't hesitate to contribute and give ideas :)</p>

<p>Full doc is in <a href="https://github.com/mandubian/scala-xmlsoap-ersatz/wiki">Github Wiki</a></p></blockquote>

<br/>


<h1>XML Scala serialization/deserialization</h1>

<h3>Imagine you want to map this XML to a case class</h3>

<pre><code>val fooXml = &lt;foo&gt;
    &lt;id&gt;1234&lt;/id&gt;
    &lt;name&gt;brutus&lt;/name&gt;
    &lt;age&gt;23&lt;/age&gt;
&lt;/foo&gt;
</code></pre>

<br/>


<h3>You want to map it to:</h3>

<pre><code>case class Foo(id: Long, name: String, age: Option[Int])
Foo(id=1234L, name="brutus", age=Some(23))
</code></pre>

<ul>
<li>case class is a sample but the mechanism also works with any structure in Scala such as tuples</li>
<li><code>age</code> field is <code>Option[Int]</code> meaning it might not appear in the XML (<code>None</code> in this case)</li>
</ul>


<br/>


<h3>So how would you write that with <em>xmlsoap ersatz</em>?</h3>

<pre><code>import play2.tools.xml._
import play2.tools.xml.DefaultImplicits._
[...]
val foo = EXML.fromXML[Foo](fooXml)
assert(foo == Foo(1234L, "brutus", Some(23)))

val fooXml2 = EXML.toXML(foo)
assert(fooXml2 == fooXml)
</code></pre>

<p>As you may imagine, this is not so simple as <code>fromXML</code>/<code>toXML</code> signatures are the following:</p>

<pre><code>object EXML {
    def toXML[T](t: T, base: xml.NodeSeq = xml.NodeSeq.Empty)(implicit w: XMLWriter[T]): xml.NodeSeq
    def fromXML[T](x: xml.NodeSeq)(implicit r: XMLReader[T]): Option[T] 
}
</code></pre>

<p>You can see the <strong>implicit typeclasses <code>XMLReader</code>/<code>XMLWriter</code></strong> which define the mapper to/from XML to your case class.
So in order <code>EXML.fromXML</code>/<code>EXML.toXML</code> to work properly, you should define an implicit XML reader/writer for your specific structure in your scope.
It can be done at once by extending <code>XMLFormatter[T]</code>:</p>

<pre><code>trait XMLFormatter[T] extends XMLReader[T] with XMLWriter[T] {
    def read(x: xml.NodeSeq): Option[T]
    def write(f: T, base: xml.NodeSeq): xml.NodeSeq
}
</code></pre>

<br/>


<h3>Defining the implicit  for your case class</h3>

<pre><code>implicit object FooXMLF extends XMLFormatter[Foo] {
  def read(x: xml.NodeSeq): Option[Foo] = {
    for( 
      id &lt;- EXML.fromXML[Long](x \ "id");
      name &lt;- EXML.fromXML[String](x \ "name");
      age &lt;- EXML.fromXML[Option[Int]](x \ "age")
    ) yield(Foo(id, name, age))
  }

  def write(f: Foo, base: xml.NodeSeq): xml.NodeSeq = {
    &lt;foo&gt;
      &lt;id&gt;{ f.id }&lt;/id&gt;
      &lt;name&gt;{ f.name }&lt;/name&gt;
      { EXML.toXML(f.age, &lt;age/&gt;) }
    &lt;/foo&gt;
  }
}
</code></pre>

<p>You may think this is a bit tedious to write but this is quite easy after a few tries and the most important:</p>

<blockquote><p>This mechanism provides a very precise and simple control on what you want to do.</p></blockquote>

<p>Please note:</p>

<ul>
<li>the <code>write</code> function uses Scala XML literals simply.</li>
<li>the <code>implicit</code> is important: you can declare it once in your scope and that's all.</li>
<li><p>the <code>age</code> field in <code>write</code> requires a special syntax:</p>

<p>  <code>{ EXML.toXML(f.age, &lt;age/&gt;) }</code> means: <code>&lt;age/&gt;</code> is used as the base node and will generate following XML:</p>

<ul>
<li>if age is <code>Some(23)</code>: <code>&lt;age&gt;23&lt;/age&gt;</code></li>
<li>if age is <code>None</code>: <code>&lt;age xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nil="true" /&gt;</code> (<em>standards defines this but you can redefine it as you want</em>)</li>
</ul>
</li>
<li><p>the <code>base</code> field in <code>write</code> function can be used to pass a parent context node to the writer. It is helpful in case you need to add attributes to parent node for ex as in the case of <code>age: Option[Int]</code> field.</p>

<blockquote><p>But don't forget that Scala XML nodes are immutable and that you can just copy the nodes you pass to a function.</p></blockquote></li>
<li><p>the <em>for-comprehension</em> is just a shortcut but you could write it using flatMap/map also:</p></li>
</ul>


<p>For ex:</p>

<pre><code>def read(x: xml.NodeSeq): Option[Foo] = {
  EXML.fromXML[Long](x \ "id").flatMap{ id =&gt;
    EXML.fromXML[String](x \ "name").flatMap { name =&gt;
      EXML.fromXML[Int](x \ "age").flatMap{ age =&gt;
        Foo(id, name, age)
      }
    }
  }
}
</code></pre>

<br/>


<h3>The complete code</h3>

<pre><code>import play2.tools.xml._
import play2.tools.xml.DefaultImplicits._

implicit object FooXMLF extends XMLFormatter[Foo] {
  def read(x: xml.NodeSeq): Option[Foo] = {
    for( 
      id &lt;- EXML.fromXML[Long](x \ "id");
      name &lt;- EXML.fromXML[String](x \ "name");
      age &lt;- EXML.fromXML[Option[Int]](x \ "age");
    ) yield(Foo(id, name, age))
  }

  def write(f: Foo, base: xml.NodeSeq): xml.NodeSeq = {
    &lt;foo&gt;
      &lt;id&gt;{ f.id }&lt;/id&gt;
      &lt;name&gt;{ f.name }&lt;/name&gt;
      { EXML.toXML(f.age, &lt;age/&gt;) }
    &lt;/foo&gt;
  }
}

val foo = EXML.fromXML[Foo](fooXml)
assert(foo == Foo(1234L, "albert", 23)

val fooXml = EXML.toXML(foo)
assert(fooXml == fooXml)
</code></pre>

<h1>Integrate with Play2/Scala</h1>

<h2>Add xmlsoap-ersatz to your confirguration (ersatz is deployed as a maven repo on github)</h2>

<pre><code>object ApplicationBuild extends Build {

  val appName         = "play2-xmlsoap"
  val appVersion      = "1.0-SNAPSHOT"

  val appDependencies = Seq(
    "play2.tools.xml" %% "xmlsoap-ersatz" % "0.1-SNAPSHOT"
  )  

  val main = PlayProject(appName, appVersion, appDependencies, mainLang = SCALA).settings(
    resolvers += ("mandubian-mvn snapshots" at "https://github.com/mandubian/mandubian-mvn/raw/master/snapshots")
  )
}
</code></pre>

<h2>Use xmlsoap-ersatz in your controller</h2>

<pre><code>package controllers

import play.api._
import play.api.mvc._
import play2.tools.xml._
import play2.tools.xml.DefaultImplicits._

object Application extends Controller {
   case class Foo(id: Long, name: String, age: Option[Int])

   implicit object FooXMLF extends XMLFormatter[Foo] {
      def read(x: xml.NodeSeq): Option[Foo] = {
      for( 
          id &lt;- EXML.fromXML[Long](x \ "id");
          name &lt;- EXML.fromXML[String](x \ "name");
          age &lt;- EXML.fromXML[Option[Int]](x \ "age")
        ) yield(Foo(id, name, age))
      }

      def write(f: Foo, base: xml.NodeSeq): xml.NodeSeq = {
        &lt;foo&gt;
          &lt;id&gt;{ f.id }&lt;/id&gt;
          &lt;name&gt;{ f.name }&lt;/name&gt;
          { EXML.toXML(f.age, &lt;age/&gt;) }
        &lt;/foo&gt;
     }
  }  

  def foo = Action(parse.xml) { request =&gt;
    EXML.fromXML[Foo](request.body).map { foo =&gt;
      Ok(EXML.toXML(foo))
    }.getOrElse{
      BadRequest("Expecting Foo XML data")
    }
  }

}
</code></pre>

<h2>Finally the route in <code>conf/routes</code></h2>

<pre><code>POST    /foo    controllers.Application.foo
</code></pre>

<p>Have fun and don't hesitate to contribute</p>
]]></content>
  </entry>
  
</feed>
